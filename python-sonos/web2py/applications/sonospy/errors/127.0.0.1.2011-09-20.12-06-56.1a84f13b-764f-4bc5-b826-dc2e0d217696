(dp1
S'output'
p2
S''
sS'layer'
p3
S'/Users/bwhitman/outside/echonest/now-playing-radiator/python-sonos/web2py/applications/sonospy/controllers/default.py'
p4
sS'code'
p5
S'# -*- coding: utf-8 -*- \nimport urllib\nimport re\nfrom xml.sax.saxutils import escape, unescape\nimport os\nimport socket\nimport time\nfrom struct import pack\nif os.name != \'nt\':\n    import fcntl\n\nsocket.setdefaulttimeout(15)\n\ndef get_ip_address(ifname):\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        ip = socket.inet_ntoa(fcntl.ioctl(s.fileno(), 0x8915, pack(\'256s\', str(ifname[:15])))[20:24])\n        return ip\n    except:\n        return socket.gethostbyname(socket.gethostname())\n\ndef get_active_ifaces():\n    if os.name == \'nt\':\n        return [socket.gethostbyname(socket.gethostname())]\n    else:\n        try:\n            rd = open(\'/proc/net/route\').readlines()\n        except (IOError, OSError):\n            return [socket.gethostbyname(socket.gethostname())]\n        net = [line.split(\'\\t\')[0:2] for line in rd]\n        return [v[0] for v in net if v[1] == \'00000000\']    \n\nactive_ifaces = get_active_ifaces()\n#print active_ifaces\nip_address = get_ip_address(active_ifaces[0])\n#print ip_address\n\nescape_entities = {\'"\' : \'&quot;\', "\'" : \'&apos;\', " " : \'%20\'}\nescape_entities_quotepos = {\'"\' : \'&quot;\', "\'" : \'&apos;\'}\nunescape_entities_quotepos = {\'&quot;\' : \'"\', \'&apos;\' : "\'"}\n\nurl_escape_entities = {\n                   " " : \'%20\',\n                   "!" : \'%21\',\n                   \'"\' : \'%22\',\n                   "#" : \'%23\',\n                   "$" : \'%24\',\n#                   "%" : \'%25\',\n                   "&" : \'%26\',\n                   "\'" : \'%27\',\n                   "(" : \'%28\',\n                   ")" : \'%29\',\n                   "*" : \'%2A\',\n                   "+" : \'%2B\',\n                   "," : \'%2C\',\n                   "-" : \'%2D\',\n                   "." : \'%2E\',\n                   "/" : \'%2F\',\n                   ":" : \'%3A\',\n                   ";" : \'%3B\',\n                   "<" : \'%3C\',\n                   "=" : \'%3D\',\n                   ">" : \'%3E\',\n                   "?" : \'%3F\',\n                   "@" : \'%40\',\n                   "[" : \'%5B\',\n                   "\\\\" : \'%5C\',\n                   "]" : \'%5D\',\n                   "^" : \'%5E\',\n                   "_" : \'%5F\',\n                   "{" : \'%7B\',\n                   "|" : \'%7C\',\n                   "}" : \'%7D\',\n                   "~" : \'%7E\',\n                  }\n\n\ndef unwrap_data(datastring):\n    # translate the string returned from the server to a list\n    datastring = escape(datastring, escape_entities_quotepos)\n    datadict = datastring.split(\'_|_\')\n    if datadict[len(datadict)-1] == \'\':\n        datadict.pop()\n    return datadict\n\ndef get_message(datadict):\n    # remove any message from the end of the controlpoint response and return it\n    message = None\n    if datadict[len(datadict)-1].startswith(\'MESSAGE::\'):\n        messagestring = datadict.pop()\n        message = messagestring.split(\'::\')[1]\n    return message\n\ndef get_return(datadict):\n    # remove any return from the end of the controlpoint response and return it\n    ret = None\n    if datadict[len(datadict)-1].startswith(\'RETURN::\'):\n        retstring = datadict.pop()\n        ret = retstring.split(\'::\')[1]\n    return ret\n\ndef index():\n    response.flash = T(\'Welcome to sonospy\')\n    # default page - get list of servers and renderers to display\n    try:\n        datastring=urllib.urlopen(\'http://\' + ip_address + \':50101/data/deviceData\').read()\n    except IOError:\n        response.flash = T(\'Unable to connect to pycpoint webserver\')\n        return dict(message=\'\')\n    \n    datadict = unwrap_data(datastring)\n    return dict(message=datadict)\n\n@service.json\ndef JSONgallery():\n    itemcount = 0\n    gallery = []\n    for row in db().select(db.album.title,db.album.creator,db.album.artname,db.album.data, orderby=db.album.title.upper()):\n        print row.title\n        print row.creator\n        print row.artname\n        print row.data\n        title = unescape(row.title, unescape_entities_quotepos)\n        if title.startswith(\'<\') and title.endswith(\'>\'): title = \'[\' + title[1:-1] + \']\'\n        creator = unescape(row.creator, unescape_entities_quotepos)\n        data = unescape(row.data, unescape_entities_quotepos)\n        gallery.append((row.artname,title,\'\',\'\',creator,data))\n        itemcount += 1\n    return gallery\n\ndef flow():\n    itemcount = 0\n    out = \'\'\n    out += \'<div id="contentflow" class="ContentFlow">\'\n    out += \'<div class="loadIndicator"><div class="indicator"></div></div>\'\n    out += \'<div class="flow" id="flowtarget">\'\n    for row in db().select(db.album.title,db.album.creator,db.album.artname,db.album.data, orderby=db.album.title.upper()):\n        print row.title\n        print row.creator\n        print row.artname\n        print row.data\n        title = unescape(row.title, unescape_entities_quotepos)\n        if title.startswith(\'<\') and title.endswith(\'>\'): title = \'[\' + title[1:-1] + \']\'\n        creator = unescape(row.creator, unescape_entities_quotepos)\n        outtitle = title + "<br/>" + creator\n        outtitle = escape(outtitle, escape_entities_quotepos)\n        data = unescape(row.data, unescape_entities_quotepos)\n        \n        datas = data.split(\'::\')\n        id = datas[0]\n        menu = datas[2]\n        \n#        if itemcount > 20: continue\n        \n        out += \'<img class="item" id="\' + id + \'" menu="\' + menu + \'" src="\' + row.artname + \'" title="\' + outtitle + \'" data="\' + data + \'"></img>\'\n        itemcount += 1\n        \n    out += \'</div>\'\n    out += \'<div class="globalCaption"></div><br/><br/><br/>\'\n    out += \'<div class="scrollbar"><div class="slider"><div class="position"></div></div></div>\'\n    out += \'</div>\'\n#    print out\n    return out\n\ndef insertalbum(id, title, creator, art, item):\n    rows = db(db.album.albumid == id).select()\n    if len(rows) == 0:\n        db.album.insert(albumid=id,\n                        title=title,\n                        creator=creator,\n                        arturi=art,\n                        artname=\'/sonospy/static/art/blank.gif\',\n                        data=item)\n    else:\n        db(db.album.id == rows[0].id).update(title=title,\n                                             creator=creator,\n                                             arturi=art,\n#                                             artname=\'/sonospy/static/art/blank.gif\',\n                                             data=item)\n\ndef clearalbums():\n    db.album.truncate()\n    redirect(\'/sonospy/default/index\')\n\n@service.json\ndef JSONloadalbumart(id=\'\'):\n    print "JSONloadalbumart"\n    print id\n    import urllib\n    if id == \'\':\n        numrecs = db(db.album.id > 0).count()\n        return[\'count=\' + str(numrecs)]    \n    else:\n        id = int(id)\n        rows = db(db.album.id == id).select(db.album.id, db.album.arturi, db.album.artname)\n        for row in rows:    # should only be one!\n            if row.arturi == \'\':\n                filename = \'applications/sonospy/static/art/blank.gif\'\n            else:        \n                localname = \'applications/sonospy/static/art/\' + str(id) + \'.jpg\'\n                print "uri: " + str(row.arturi)\n                print "lname: " + str(localname)\n                (filename, headers) = urllib.urlretrieve(row.arturi, localname)\n                print "headers: " + str(headers)\n                if not \'Content-Type\' in headers or headers[\'Content-Type\'] == \'text/html\':\n                    filename = \'applications/sonospy/static/art/blank.gif\'\n            filename = filename[12:]\n            print "fname: " + str(filename)\n            db(db.album.id == row.id).update(artname = filename)\n        return [id, filename]\n\n\ndef setrenderer():\n    # tell the controlpoint which renderer is current\n    print "---- setrenderer -----------------------------------"\n    print "renderertitle: " + str(request.vars.renderertitle)\n    print "renderertype: " + str(request.vars.renderertype)\n    print "renderertarget: " + str(request.vars.renderertarget)\n    print "queuetarget: " + str(request.vars.queuetarget)\n    print "queuedata: " + str(request.vars.queuedata)\n    print "queuechain: " + str(request.vars.queuechain)\n\n    ptitle = escape(request.vars.renderertitle, url_escape_entities)\n    ptype = request.vars.renderertype\n    ptarget = request.vars.renderertarget\n    qtarget = request.vars.queuetarget\n    qdata = request.vars.queuedata\n    qchainparams = request.vars.queuechain\n\n    pentry = ptype + \'::\' + ptitle\n    print "entry: " + str(pentry)\n\n    # get the meta data for this renderer\n    datastring=urllib.urlopen(\'http://\' + ip_address + \':50101/data/rendererData?data=\'+pentry).read()\n    datadict = unwrap_data(datastring)\n\n    print "rendererData: " + str(datadict)\n    print\n\n    dataout = \'\'\n    queueentry = \'\'\n    for item in datadict:\n        colonpos = item.find(\'::\')\n        id = item[:colonpos]\n        text = item[colonpos+2:]\n        if id == \'QUEUE\':\n            # this is the queue entry name\n            dataout += "update_queueentry(\'" + text + "\');"\n            queueentry = text\n\n    # get the now playing data for this renderer\n    datastring=urllib.urlopen(\'http://\' + ip_address + \':50101/data/rendererPoll?data=\'+pentry).read()\n    datadict = unwrap_data(datastring)\n\n    print "rendererPoll: " + str(datadict)\n    print\n\n    pollout = formatrendererstatus(datadict)\n\n    # create queue browse script if appropriate\n    queuescript = \'\'\n    if queueentry != \'\':\n        qentries = queueentry.split(\'::\')\n        qid = qentries[0]\n        qtype = qentries[1]\n        qmenu = qentries[2]\n        qtext = qentries[3]\n        qoption = \'tree\'\n        qstring = \'\'\n        qoperator = \'\'\n        qparams = [\'paramtitle=\'+qtext, \'paramtype=\'+qtype, \'paramtarget=\'+qtarget, \'paramid=\'+qid, \'paramoption=\'+qoption, \'parammenutype=\'+qmenu, \'searchstring=\'+qstring, \'searchoperator=\'+qoperator, \'browsedata=\'+qdata, \'chainparams=\'+qchainparams]        \n        queuescript1 = "ajax2(\'getdata\', " + str(qparams) + ", \':eval\');"\n        # adjust qdata for subsequent calls - pass 0 as sequence\n        qdata = \'0\' + qdata[1:]\n        qparams = [\'paramtitle=\'+qtext, \'paramtype=\'+qtype, \'paramtarget=\'+qtarget, \'paramid=\'+qid, \'paramoption=\'+qoption, \'parammenutype=\'+qmenu, \'searchstring=\'+qstring, \'searchoperator=\'+qoperator, \'browsedata=\'+qdata, \'chainparams=\'+qchainparams]        \n        queuescript2 = "ajax2(\'getdata\', " + str(qparams) + ", \':eval\');"\n        queuescript += queuescript1 + "update_queuecall(\\"" + queuescript2 + "\\");"\n    else:\n        # need to clear queue from html\n        queuescript = "jQuery(\'#" + qtarget + "\').html(\'\');"\n\n#    print "setrenderer return: "\n#    print "dataout: " + str(dataout)\n#    print "pollout: " + str(pollout)\n#    print "queuescript: " + str(queuescript)\n\n    allout = dataout + pollout + queuescript\n\n#    print "allout: " + str(allout)\n\n    return allout\n    \ndef controlrenderer():\n    # tell renderer to perform an action\n    print "---- controlrenderer -----------------------------------"\n    print "paramoption: " + str(request.vars.paramoption)\n    poption = request.vars.paramoption\n    datastring=urllib.urlopen(\'http://\' + ip_address + \':50101/data/rendererAction?data=\'+poption).read()\n    return ""\n    \ndef pollrenderer():\n    # get the current play status of the current renderer\n    ptitle = escape(request.vars.renderertitle, url_escape_entities)\n    ptype = request.vars.renderertype\n    ptarget = request.vars.renderertarget\n    pentry = ptype + \'::\' + ptitle\n    datastring=urllib.urlopen(\'http://\' + ip_address + \':50101/data/rendererPoll?data=\'+pentry).read()\n    datadict = unwrap_data(datastring)\n    out = formatrendererstatus(datadict)\n    return out\n\ndef formatrendererstatus(datadict):\n    # format the renderer play status\n    out = \'\'\n    for item in datadict:\n        entry = item.split(\'::\')\n        id = entry[0]\n        if len(entry) == 1:\n            # some entries can validly have blank text\n            if id == \'TRACK\' or id == \'ARTIST\' or id == \'ALBUM\' or id == \'STATION\' or id == \'ONNOW\' or id == \'INFO\':\n                text = \'-\'\n            elif id == \'ART\':\n                # for art use default image\n                text = "/sonospy/static/artist.png"\n            else:\n                # entry has no text, ignore entry\n                continue\n        else:\n            text = entry[1]\n        if id == \'TRACK\':\n            out += "jQuery(\'#TITLE1\').html(\'Track\');"\n            out += "jQuery(\'#LINE1\').html(\'" + text + "\');"\n        elif id == \'ARTIST\':\n            out += "jQuery(\'#TITLE2\').html(\'Artist\');"\n            out += "jQuery(\'#LINE2\').html(\'" + text + "\');"\n        elif id == \'ALBUM\':\n            out += "jQuery(\'#TITLE3\').html(\'Album\');"\n            out += "jQuery(\'#LINE3\').html(\'" + text + "\');"\n        elif id == \'STATION\':\n            out += "jQuery(\'#TITLE1\').html(\'Station\');"\n            out += "jQuery(\'#LINE1\').html(\'" + text + "\');"\n        elif id == \'ONNOW\':\n            out += "jQuery(\'#TITLE2\').html(\'On Now\');"\n            out += "jQuery(\'#LINE2\').html(\'" + text + "\');"\n        elif id == \'INFO\':\n            out += "jQuery(\'#TITLE3\').html(\'Info\');"\n            out += "jQuery(\'#LINE3\').html(\'" + text + "\');"\n        elif id == \'ART\':\n#            out += "jQuery(\'#ART\').html(\'<img src=\\"" + text + "\\" class=\\"albumart\\"></img>\');"\n            out += "jQuery(\'#ART\').html(\'<img src=\\"/sonospy/static/spinnerlarge.gif\\" onLoad=\\"replaceImage(this, &quot;" + text + "&quot)\\" class=\\"albumart\\"></img>\');"\n        elif id == \'POSITION\':\n            if text != \'0:00:00\':\n                out += "jQuery(\'#POSITION\').html(\'" + text + "<br/>\');"\n        elif id == \'PERCENT\':\n            out += "setprogressbar(" + text + ");"\n        elif id == \'VOLUME\':\n            out += "setvolumeslider(" + text + ");"\n        elif id == \'VOLUME_FIXED\':\n            out += "disablevolumeslider(" + text + ");"\n        elif id == \'MUTE\':\n            out += "setmute(" + text + ");"\n        elif id == \'STATE\':\n            out += "setplay(\'" + text + "\');"\n    # recalc the height in case we changed the playing area height\n    out += "setheight();"\n    return out\n    \ndef pollserver():\n    # get the current update status of the current server\n    ptitle = escape(request.vars.servertitle, url_escape_entities)\n    ptype = request.vars.servertype\n    qdata = request.vars.queuedata\n    pentry = ptype + \'::\' + ptitle\n    datastring=urllib.urlopen(\'http://\' + ip_address + \':50101/data/serverPoll?data=\'+pentry).read()\n    datadict = unwrap_data(datastring)\n\n    print "pollserver return: " + str(datadict)\n\n    out = \'\'\n    for item in datadict:\n        entry = item.split(\'::\')\n        id = entry[0]\n        text = entry[1]\n#        if id == \'QUEUE\':\n#            # the queue has changed, need to update it\n#            # qdata contains a pre-formatted ajax call for the queue\n#            out += qdata\n#    print out\n\n    return out\n\ndef pollqueue():\n#    print "---- pollqueue -----------------------------------"\n#    print "queueentry: " + str(request.vars.queueentry)\n#    print "queuecall: " + str(request.vars.queuecall)\n    # get the current update status of the current queue\n    qentry = escape(request.vars.queueentry, url_escape_entities)\n    qcall = request.vars.queuecall\n\n    datastring=urllib.urlopen(\'http://\' + ip_address + \':50101/data/queuePoll?data=\'+qentry).read()\n    datadict = unwrap_data(datastring)\n    out = \'\'\n    for item in datadict:\n        entry = item.split(\'::\')\n        id = entry[0]\n        text = entry[1]\n        if id == \'QUEUE\':\n            # the queue has changed, need to update it\n            # qcall contains a pre-formatted ajax call for the queue\n            out += qcall\n    return out\n\ndef getrootdata():\n    # get the root data for the selected UPnP server\n    print "---- getrootdata -----------------------------------"\n    print "paramtitle: " + str(request.vars.paramtitle)\n    print "paramtype: " + str(request.vars.paramtype)\n    print "paramtarget: " + str(request.vars.paramtarget)\n    \n    ptitle = escape(request.vars.paramtitle, url_escape_entities)\n    ptype = request.vars.paramtype\n    ptarget = request.vars.paramtarget\n    pentry = ptype + \'::\' + ptitle\n    print "entry: " + str(pentry)\n\n    # first get all the context menus for this server\n    datastring=urllib.urlopen(\'http://\' + ip_address + \':50101/data/rootMenus?data=\'+pentry).read()\n    datadict = unwrap_data(datastring)\n\n    # format the menus - create Javascript functions to load them\n    # (we use individual functions as only the first one works if\n    # we concatenate them all together (at least in Firefox))\n    # Note that the first set is not a menu but the default action(s) for double click\n    menucount = int(datadict[0])\n    defaultscript = \'\'\n    defaultscriptname = \'\'\n    menuscripts = []\n    menuscripttext = \'\'\n    i = 1\n    # process default option(s)\n    entrycount = int(datadict[i])\n    defaultscriptname = datadict[i+1]\n    i += 2\n    defaultscript += \'function \' + defaultscriptname + \'() {\'\n    for e in range(entrycount):\n        menuid = datadict[i]\n        menutext = datadict[i+1]\n        i += 2\n        defaultscript += \'processmenu("\' + menuid + \'");\'\n    defaultscript += \'};\'\n    menuscripts.append(defaultscript)\n    # process the menus\n    for m in range(1,menucount):\n        entrycount = int(datadict[i])\n        menuname = datadict[i+1]\n        i += 2\n        menuscripttext += \'function \' + menuname + \'(id) {\'\n        menuscripttext += \'  var menu = [\'\n        for e in range(entrycount):\n            menuid = datadict[i]\n            menutext = datadict[i+1]\n            i += 2\n            if menuid == \'SEP\' and menutext == \'SEP\':\n                menuscripttext += \'    $.contextMenu.separator,\'\n            else:\n                menuscripttext += \'    { "\' + menutext + \'": function(menuItem,menuObject) { processmenu("\' + menuid + \'",menuObject.target); } },\'\n        menuscripttext += \'  ];\'\n        menuscripttext += \'  ret=$(id).contextMenu(menu,{beforeShow:function bs(e){return beforeshowmenu(e)},afterShow:function as(m){aftershowmenu(m)}});\'\n        menuscripttext += \'  return ret;\'\n        menuscripttext += \'};\'\n        menuscripts.append(menuscripttext)\n        menuscripttext = \'\'\n    print menuscripts\n\n    # get root entries for this server\n    datastring=urllib.urlopen(\'http://\' + ip_address + \':50101/data/rootData?data=\'+pentry).read()\n    datadict = unwrap_data(datastring)\n\n    # remove any message\n    messagescript = \'\'\n    message = get_message(datadict)\n    if message == None or message == \'\':\n        message = \'Ready\'\n    messagescript = \'setmessagebar("\' + message + \'");\'\n\n    # format the root entries - create an accordion\n    out = \'\'\n    itemcount = 0\n    for item in datadict:\n        entry = item.split(\'::\')\n        id = entry[0]\n        type = entry[1]\n        menu = entry[2]\n        text = entry[3]\n        if itemcount > 0:\n            out += \'</span>\'\n        if itemcount == 0:\n            out += \'<div id="accordion">\'\n        itemcount += 1\n        \n        if text == \'Current Queue\':\n            # don\'t display queue\n            continue\n        \n        atarget = \'"atarget\' + id + \'"\'\n        target = \'"target\' + id + \'"\'\n        out += \'<h3 accord="closed"><a id=\' + atarget + \' href="#" menu="\' + menu + \'" type="\' + type + \'">\' + text + \'<span class="ui-icon ui-icon-triangle-1-ne"></span></a></h3>\'\n        out += \'<span id=\' + target + \'>\'\n    if itemcount > 0:\n        out += \'</span></div>\'\n\n    # create a script to load the menu scripts we just created\n    callscript = \'\'    \n    for menuscript in menuscripts:\n        callscript += \'var headID = document.getElementsByTagName("head")[0];\'\n        callscript += \'var script = document.createElement("script");\'\n        callscript += \'script.type = "text/javascript";\'\n        callscript += \'script.text = \' + menuscript + \';\'\n        callscript += \'headID.appendChild(script);\'\n\n    # create a script to store the default option script name\n    defaultscript = \'document.forms[0].elements["defaultoptionname"].value="\' + defaultscriptname + \'";\'\n\n    # return the scripts we want to run:\n    #     set the target html to be the accordion\n    #     call the accordion creation function\n    #     execute the script to load the menu creation scripts\n    #     execute the script to bind the menus\n    return "eval(\'" + messagescript + "\');jQuery(\'#" + ptarget + "\').html(\'" + out + "\');liveaccordion();eval(\'" + callscript + "\');eval(\'" + defaultscript + "\');"\n\n\ndef getdata():\n    # get data from the server relating to the parameter values\n    print "---- getdata -----------------------------------"\n    print "paramtitle: " + str(request.vars.paramtitle)\n    print "paramtype: " + str(request.vars.paramtype)\n    print "paramtarget: " + str(request.vars.paramtarget)\n    print "paramid: " + str(request.vars.paramid)\n    print "paramoption: " + str(request.vars.paramoption)\n    print "parammenutype: " + str(request.vars.parammenutype)\n    print "searchstring: " + str(request.vars.searchstring)\n    print "searchoperator: " + str(request.vars.searchoperator)\n    print "browsedata: " + str(request.vars.browsedata)\n    print "chainparams: " + str(request.vars.chainparams)\n    \n    ptitle = escape(request.vars.paramtitle, url_escape_entities)\n    ptype = request.vars.paramtype\n    ptarget = request.vars.paramtarget\n    pid = request.vars.paramid\n    poption = request.vars.paramoption\n    pmenu = request.vars.parammenutype\n    psearch = escape(request.vars.searchstring, url_escape_entities)\n    poperator = request.vars.searchoperator\n    pdata = request.vars.browsedata\n    pchain = request.vars.chainparams\n\n    s_vars = True\n    if \'s_id\' in request.vars.keys():\n        ps_id = request.vars.s_id\n    else:\n        s_vars = False\n    if \'s_type\' in request.vars.keys():\n        ps_type = request.vars.s_type\n    else:\n        s_vars = False\n\n    s_name = True\n    if \'searchname\' in request.vars.keys():\n        searchname = request.vars.searchname\n    else:\n        s_name = False\n\n    datas = pdata.split(\',\')\n    dataseq = int(datas[0])\n    datastart = int(datas[1])\n    datacount = int(datas[2])\n\n    # format request entry\n    pentry = pid + \'::\' + ptype + \'::\' + pmenu + \'::\' + ptitle\n    \n    # append server id and type if passed\n    if s_vars == True:\n        pentry += \'::\' + ps_id + \'::\' + ps_type\n\n    pentry += \'::\' + pdata\n\n    # append search vars if present    \n    if psearch != "":\n        pentry += \':::\' + psearch    \n    if poperator != "":\n        pentry += \'::\' + poperator\n    print "entry: " + str(pentry)\n\n    gotdata = False\n    while gotdata == False:\n        # get data from the server\n        datastring=urllib.urlopen(\'http://\' + ip_address + \':50101/data/getData?data=\'+pentry).read()\n        datadict = unwrap_data(datastring)\n        # check whether we have received any data\n        if datadict[0].startswith(\'NOTREADY\'):\n            time.sleep(0.3)\n        else:\n            gotdata = True            \n\n    # remove any message\n    messagescript = \'\'\n    message = get_message(datadict)\n    if message != None:\n        messagescript = \'setmessagebar("\' + message + \'");\'\n\n    # remove any return totals (must be present)\n    messagescript = \'\'\n    ret = get_return(datadict)\n    rets = ret.split(\':\')\n    retcount = int(rets[0])\n    rettotal = int(rets[1])\n    newtotal = datastart + retcount\n\n    # special case - reset dataseq if it was called with zero\n    if dataseq == 0:\n        dataseq = 1\n    \n    # calc number of calls needed\n    if dataseq == 1:\n        recallcount = (rettotal / datacount) + 1\n\n    # decide whether we want to separate\n    chainparams = pchain.split(\',\')\n    chainseparate = chainparams[0]\n    if chainseparate == \'1\': separate = True\n    else: separate = False\n    currentletter = \'\'\n    if separate == True:\n        currentletter = chainparams[1]\n        currenttarget = chainparams[2]\n    if separate == True and dataseq == 1 and rettotal < 54:\n        # not enough entries to separate - reset separate\n        chainseparate == \'0\'\n        separate = False\n\n    message = "Returned " + str(newtotal) + " of " + str(rettotal)\n    messagescript += \'setmessagebar("\' + message + \'");\'\n\n    # format the data received from the server as an unordered list\n    out = \'\'\n\n    firstsep = False        \n    if dataseq == 1:\n        firstsep = True\n        if separate == False:\n            out += \'<ul type="none" id="navigation">\'\n        \n    foldercount = 0\n    searchitems = []\n    multipletargets = \'\'\n    allletters = []\n    lettercount = 0\n\n    # TODO: simplify all these booleans\n    prevseparate = False\n    firstseparate = True\n    \n    for item in datadict:\n\n        extraentry = None\n        rementry = item\n        if \'::::\' in rementry:\n            # this entry contains extra details\n            entries = rementry.split(\'::::\')\n            rementry = entries[0]\n            extraentry = entries[1].split(\'::\')\n        if \':::\' in rementry:\n            # this entry contains search criteria\n            entries = rementry.split(\':::\')\n            rementry = entries[0]\n            searchentry = entries[1].split(\'::\')\n            searchtype = searchentry[0]\n            if len(searchentry) >= 2:\n                searchcriteria = searchentry[1]\n            else:\n                searchcriteria = None\n            if len(searchentry) == 3:\n                searchoperators = searchentry[2]\n            else:\n                searchoperators = None\n        # must be a base entry\n        entry = rementry.split(\'::\')\n        \n        id = entry[0]\n        type = entry[1]\n        menu = entry[2]\n        text = entry[3]\n        \n#        s_id = entry[4]\n#        s_type = entry[5]\n        \n        target = \'target\' + str(id)\n        atarget = \'"atarget\' + id + \'"\'\n        ref = \'?\' + target\n\n        if separate == True:\n            newbreak = False\n        \n            # check whether we need to separate\n            thisletter = text[:1].upper()\n\n            if thisletter.isalpha():\n                if thisletter != currentletter:\n                    currentletter = thisletter\n                    newbreak = True\n            else:\n                if currentletter == \'\':\n                    currentletter = \'#\'\n                    newbreak = True\n\n#            if newbreak == False and firstseparate == True and currenttarget != \'\':\n            if newbreak == False and firstseparate == True:\n            \n                # this is a continuation of a previous separate - need to indent\n                if currenttarget == \'\':\n                    out = \'<ul>\' + out\n                else:\n                    out = \'<li><span id="\' + currenttarget + \'"><ul>\' + out\n                firstseparate = False\n\n            if newbreak == True:\n\n                if firstsep == False:\n\n                    if prevseparate == True:\n                        out += \'</ul>\'\n                        out += \'</li>\'\n                        prevseparate = False\n\n                    # it\'s possible that there isn\'t a preceding <li> entry in this pass (will be in a previous pass)\n                    # - if so we need to add one otherwise the replace will remove the </li> we are about to add\n                    # TODO: only check this once\n                    if out.find(\'<li\') == -1:\n                        out = \'<li><ul>\' + out\n                        prevseparate = True\n                    \n                    out += \'</ul>\'\n                    out += \'</li>\'\n\n                else:\n                    firstsep = False\n\n                allletters.append(currentletter)\n                lettercount += 1\n                l_target = \'target\' + \'__\' + str(lettercount)\n                l_atarget = \'"atarget\' + \'__\' + str(lettercount) + \'"\'\n                l_menu = \'NONE\'\n                l_type = \'C\'\n                l_text = currentletter\n                l_icon = \'<span class="ui-icon ui-icon-minus" style="float:left"></span>\'\n#                l_play = \' class="dummy"\'\n                l_play = \'\'\n                out += \'<li tree="open" visited="y"\' + l_play + \'><span type="\' + l_type + \'"><a id=\' + l_atarget + \' menu="\' + l_menu + \'" type="\' + l_type + \'">\' + l_icon + l_text + \'</a></span><span id="s\' + l_target + \'"></span><span id="\' + l_target + \'">\'\n                out += \'<ul type="none" id="navigation">\'\n\n            else:\n\n                l_target = \'target\' + \'__\' + str(lettercount)\n                \n        play = \'\'\n        search = \'\'\n        if type == \'T\':\n            icon = \'<span style="float:left"></span><img src="/sonospy/static/note.png">\'\n            play = \' class="play"\'\n        if type == \'N\':\n            icon = \'<span style="float:left"></span><img src="/sonospy/static/block.png">\'\n            play = \' class="dummy"\'\n        elif type == \'C\':\n#            icon = \'<span class="ui-icon ui-icon-plus" style="float:left"></span><img src="">\' #TODO: check whether we need a null image\n            icon = \'<span class="ui-icon ui-icon-plus" style="float:left"></span><span class="ui-icon ui-icon-triangle-1-ne" style="float:right"></span>\'\n        elif type == \'A\':\n            icon = \'<span class="ui-icon ui-icon-plus" style="float:left"></span><img src="/sonospy/static/album.png">\'\n        elif type == \'B\':\n            icon = \'<span class="ui-icon ui-icon-plus" style="float:left"></span><img src="/sonospy/static/artist.png">\'\n        elif type == \'S\':\n            icon = \'<span style="float:left"></span><img src="/sonospy/static/search.png">\'\n            search = \' searchtype="\' + searchtype + \'"\'\n            if text != \'ALL\':\n                searchitems.append(id + "::" + text)\n            else:\n                # have a multiple search option - pass the other options through\n                c = 1\n                st = \'\'\n                for si in searchitems:\n                    itemname = si.split("::")[1]\n                    multipletargets += \'<span id="\' + target + \'__\' + str(c) + \'" sname="\' + itemname + \'"></span>\'\n                    st += si + \'__\'\n                    c += 1\n                search += \' searchtype2="\' + st[:-2] + \'"\'\n            if searchcriteria != None:\n                search += \' searchcriteria="\' + searchcriteria + \'"\'\n            if searchoperators != None:\n                search += \' searchoperators="\' + searchoperators + \'"\'\n        \n        extras = \'\'\n        extracreator = \'\'\n        extraalbum = \'\'\n        extraart = \'\'\n        if extraentry != None:\n            for ex in extraentry:\n                if ex.startswith(\'creator=\'):\n                    extracreator = ex[8:]\n                    extras += \'<span class="extra"> [\' + extracreator + \']</span>\'\n                elif ex.startswith(\'album=\'):\n                    extraalbum = ex[6:]\n                    extras += \'<span class="extra"> [\' + extraalbum + \']</span>\'\n                elif ex.startswith(\'art=\'):\n                    extraart = ex[4:]\n            if type == \'C\':     # this works at the moment because the only container with extras is album\n                insertalbum(id, text, extracreator, extraart, item)\n                \n        out += \'<li tree="closed"\' + play + search + \'><span type="\' + type + \'"><a id=\' + atarget + \' menu="\' + menu + \'" type="\' + type + \'">\' + icon + text + extras + \'</a></span><span id="s\' + target + \'"></span><span id="\' + target + \'"></span>\' + multipletargets + \'</li>\'\n\n        foldercount += 1\n\n    # check if we received all entries\n    chainscript = \'\'\n    iconscript = \'\'\n    if newtotal < rettotal:\n\n        # there are more entries so we want to chain another ajax call\n        # update the data values\n        if (rettotal - newtotal) < datacount: datacount = rettotal - newtotal\n        nextdata = str(dataseq+1) + \',\' + str(newtotal) + \',\' + str(datacount)\n        # update the target\n        target_base = ptarget.split(\'-\')[0]\n        nexttarget = target_base + \'-\' + str(dataseq+1)\n\n        # check if we need to close a separate\n        if separate == True:\n            out += \'</ul>\'\n            out += \'</span></li>\'\n\n        # create targets for remaining calls\n        if dataseq == 1:\n            for call in range(recallcount):\n                calltarget = target_base + \'-\' + str(dataseq+call+1)\n                out += \'<span id="\' + calltarget + \'"></span>\'\n\n        # set chain params\n        chainparams = chainseparate + \',\'\n        if chainseparate == \'1\':\n            chainparams += currentletter\n            # add letter continuation target\n            du = l_target.split(\'__\')\n            if len(du) == 1: cont = \'1\'\n            else: cont = str(int(du[1])+1)\n            chainparams += \',\' + du[0] + \'__\' + cont\n            \n        # call again - use call that doesn\'t use form fields in case user is making another call\n        params = [\'paramtitle=\'+ptitle, \'paramtype=\'+ptype, \'paramtarget=\'+nexttarget, \'paramid=\'+pid, \'paramoption=\'+poption, \'parammenutype=\'+pmenu, \'searchstring=\'+psearch, \'searchoperator=\'+poperator, \'browsedata=\'+nextdata, \'chainparams=\'+chainparams]        \n        chainscript += "ajax2(\'getdata\', " + str(params) + ", \':eval\');"\n\n    else:\n        # there are no more browse entries\n        # finalise separator\n\n        if separate == True:\n            out += \'</ul>\'\n            out += \'</li>\'\n        # finalise list\n        out += \'</ul>\'\n        # create a script to post process the server data icon after updating\n        if poption == \'tree\':\n            iconscript = "jQuery(\'.clicker\').attr(\'class\', \'ui-icon ui-icon-minus\').removeClass(\'clicker\');"\n        elif poption == \'accord\':\n            iconscript = "jQuery(\'.clicker\').removeClass(\'ui-icon-refresh\').addClass(\'ui-icon-triangle-1-s\').removeClass(\'clicker\');"\n\n    # return the scripts we want to run:\n    #     set the target html to be the list\n    #     call the post processing script\n    \n#    print "ptarget: " + str(ptarget)\n#    print "out: " + str(out)\n\n    height = "setheight();"\n    \n    if dataseq <= 1 or separate == False:\n        # prepend name separator if specified\n        if s_name:\n            out = searchname + out\n        \n        return "eval(\'" + messagescript + "\');jQuery(\'#" + ptarget + "\').html(\'" + out + "\');" + chainscript + iconscript + height\n    else:    \n        return "eval(\'" + messagescript + "\');jQuery(\'#" + ptarget + "\').replaceWith(\'" + out + "\');" + chainscript + iconscript + height\n\ndef calloption():\n    # tell the controlpoint to perform the passed function on the passed item\n    print "---- calloption -----------------------------------"\n    print "paramtitle: " + str(request.vars.paramtitle)\n    print "paramtype: " + str(request.vars.paramtype)\n    print "paramtarget: " + str(request.vars.paramtarget)\n    print "paramid: " + str(request.vars.paramid)\n    print "parammenuoption: " + str(request.vars.parammenuoption)\n    print "parammenutype: " + str(request.vars.parammenutype)\n \n    ptitle = escape(request.vars.paramtitle, url_escape_entities)\n    ptype = request.vars.paramtype\n    ptarget = request.vars.paramtarget\n    pid = request.vars.paramid\n    poption = request.vars.parammenuoption\n    pmenu = request.vars.parammenutype\n    \n    if ptype == "":\n        pentry = pid + \'::\' + pmenu + \'::\' + ptitle + ":::" + poption\n    else:\n        pentry = pid + \'::\' + ptype + \'::\' + pmenu + \'::\' + ptitle + ":::" + poption\n    print "entry: " + str(pentry)\n    datastring=urllib.urlopen(\'http://\' + ip_address + \':50101/data/playData?data=\'+pentry).read()\n\n    return ""\n\ndef calloptionmulti():\n    # tell the controlpoint to perform the passed function on the passed item list\n    print "---- calloptionmulti -----------------------------------"\n    print "data: " + str(request.vars.data)\n    print "option: " + str(request.vars.option)\n \n    pdata = escape(request.vars.data, url_escape_entities)\n    poption = request.vars.option\n    \n    pentry = \'MULTI\' + \':::\' + poption + \':::\' + pdata\n    print "entry: " + str(pentry)\n    datastring=urllib.urlopen(\'http://\' + ip_address + \':50101/data/playData?data=\'+pentry).read()\n\n    return ""\n\n\ndef user():\n    """\n    exposes:\n    http://..../[app]/default/user/login \n    http://..../[app]/default/user/logout\n    http://..../[app]/default/user/register\n    http://..../[app]/default/user/profile\n    http://..../[app]/default/user/retrieve_password\n    http://..../[app]/default/user/change_password\n    use @auth.requires_login()\n        @auth.requires_membership(\'group name\')\n        @auth.requires_permission(\'read\',\'table name\',record_id)\n    to decorate functions that need access control\n    """\n    return dict(form=auth())\n\n\ndef download():\n    """\n    allows downloading of uploaded files\n    http://..../[app]/default/download/[filename]\n    """\n    return response.download(request,db)\n\n\ndef call():\n    """\n    exposes services. for example:\n    http://..../[app]/default/call/jsonrpc\n    decorate with @services.jsonrpc the functions to expose\n    supports xml, json, xmlrpc, jsonrpc, amfrpc, rss, csv\n    """\n    session.forget()\n    return service()\n\nresponse._vars=response._caller(controlrenderer)\n'
p6
sS'traceback'
p7
S'Traceback (most recent call last):\n  File "/Users/bwhitman/outside/echonest/now-playing-radiator/python-sonos/web2py/gluon/restricted.py", line 173, in restricted\n    exec ccode in environment\n  File "/Users/bwhitman/outside/echonest/now-playing-radiator/python-sonos/web2py/applications/sonospy/controllers/default.py", line 969, in <module>\n  File "/Users/bwhitman/outside/echonest/now-playing-radiator/python-sonos/web2py/gluon/globals.py", line 96, in <lambda>\n    self._caller = lambda f: f()\n  File "/Users/bwhitman/outside/echonest/now-playing-radiator/python-sonos/web2py/applications/sonospy/controllers/default.py", line 298, in controlrenderer\n    datastring=urllib.urlopen(\'http://\' + ip_address + \':50101/data/rendererAction?data=\'+poption).read()\n  File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib.py", line 84, in urlopen\n    return opener.open(url)\n  File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib.py", line 205, in open\n    return getattr(self, name)(url)\n  File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib.py", line 342, in open_http\n    h.endheaders(data)\n  File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/httplib.py", line 937, in endheaders\n    self._send_output(message_body)\n  File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/httplib.py", line 797, in _send_output\n    self.send(msg)\n  File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/httplib.py", line 759, in send\n    self.connect()\n  File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/httplib.py", line 740, in connect\n    self.timeout, self.source_address)\n  File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/socket.py", line 571, in create_connection\n    raise err\nIOError: [Errno socket error] [Errno 61] Connection refused\n'
p8
s.